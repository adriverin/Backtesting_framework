<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Trading Dashboard</title>
	<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
	<style>
		body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: #0b1020; color: #e6e8ef; }
		h1 { font-weight: 600; }
		.container { display: grid; grid-template-columns: 2fr 1fr; gap: 16px; padding: 16px; }
		.card { background: #121936; border-radius: 12px; padding: 12px 14px; box-shadow: 0 0 0 1px #1d274d inset; }
		.feed { max-height: 60vh; overflow: auto; }
		.row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px dashed #223; }
		.row:last-child { border-bottom: 0; }
		.buy { color: #4ade80; }
		.sell { color: #f87171; }
		.small { color: #9aa3b2; font-size: 12px; }
		.controls { margin: 8px 0; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
		input, select { background: #0f1530; color: #e6e8ef; border: 1px solid #1d274d; border-radius: 8px; padding: 6px 8px; }
		button { background: #2b5fd9; color: white; border: 0; border-radius: 8px; padding: 6px 10px; cursor: pointer; }
		button:hover { background: #1e46a3; }
		.kpis { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; }
		.kpi { background: #0f1530; border: 1px solid #1d274d; border-radius: 10px; padding: 10px; }
		.kpi .label { font-size: 12px; color: #9aa3b2; }
		.kpi .value { font-size: 18px; font-weight: 600; }
		.badge { display: inline-block; background: #0f1530; border: 1px solid #1d274d; border-radius: 999px; padding: 4px 8px; font-size: 12px; color: #c7cdd8; margin-left: 8px; }
	</style>
</head>
<body>
	<h1>Trading Dashboard <span id="session_info" class="badge"></span></h1>
	<div class="controls">
		<label>Symbol <input id="symbol" value="VETUSDT" /></label>
		<label>Timeframe
			<select id="tf">
				<option value="1m">1m</option>
				<option value="5m">5m</option>
				<option value="15m">15m</option>
				<option value="1h">1h</option>
				<option value="4h" selected>4h</option>
				<option value="1d">1d</option>
			</select>
		</label>
		<label>From <input id="from" type="date" /></label>
		<label>To <input id="to" type="date" /></label>
		<button id="refresh">Refresh</button>
		<span class="small">Reads NDJSON from ./logs/</span>
	</div>
	<div class="container">
		<div class="card">
			<h3>Candles + Trades</h3>
			<div id="candles" style="height: 420px"></div>
		</div>
		<div class="card">
			<h3>Metrics</h3>
			<div class="kpis">
				<div class="kpi"><div class="label">Trades</div><div id="k_trades" class="value">-</div></div>
				<div class="kpi"><div class="label">Win Rate</div><div id="k_win" class="value">-</div></div>
				<div class="kpi"><div class="label">Gross PnL</div><div id="k_gross" class="value">-</div></div>
				<div class="kpi"><div class="label">Fees</div><div id="k_fees" class="value">-</div></div>
				<div class="kpi"><div class="label">Net PnL</div><div id="k_net" class="value">-</div></div>
				<div class="kpi"><div class="label">Max DD</div><div id="k_dd" class="value">-</div></div>
				<div class="kpi"><div class="label">Avg Win</div><div id="k_avg_win" class="value">-</div></div>
				<div class="kpi"><div class="label">Avg Loss</div><div id="k_avg_loss" class="value">-</div></div>
				<div class="kpi"><div class="label">Profit Factor</div><div id="k_pf" class="value">-</div></div>
				<div class="kpi"><div class="label">Expectancy</div><div id="k_expect" class="value">-</div></div>
				<div class="kpi"><div class="label">Unrealized</div><div id="k_unreal" class="value">-</div></div>
			</div>
		</div>
		<div class="card" style="grid-column: 1 / span 2">
			<h3>Equity (Quote)</h3>
			<div id="equity_quote" style="height: 240px"></div>
		</div>
		<div class="card" style="grid-column: 1 / span 2">
			<h3>Trade Feed</h3>
			<div class="feed" id="feed"></div>
		</div>
	</div>

	<script>
	const sleep = (ms) => new Promise(r => setTimeout(r, ms));

	async function fetchNDJSON(path) {
		try {
			const resp = await fetch(path + `?t=${Date.now()}`);
			if (!resp.ok) return [];
			const text = await resp.text();
			return text.trim().split("\n").filter(Boolean).map(line => {
				try { return JSON.parse(line); } catch { return null; }
			}).filter(Boolean);
		} catch (e) { return [];} 
	}

	async function fetchHead(path) {
		try {
			const resp = await fetch(path + `?t=${Date.now()}`, { method: 'HEAD' });
			return resp.ok;
		} catch (e) { return false; }
	}

	async function fetchMany(paths) {
		const results = await Promise.all(paths.map(p => fetchNDJSON(p)));
		return results.flat();
	}

	function dateRangeStrings(fromStr, toStr, fallbackDays=30) {
		const today = new Date();
		let from = fromStr ? new Date(fromStr) : new Date(today.getTime() - fallbackDays*24*3600*1000);
		let to = toStr ? new Date(toStr) : today;
		from.setHours(0,0,0,0); to.setHours(0,0,0,0);
		const dates = [];
		for (let d = new Date(from); d <= to; d.setDate(d.getDate()+1)) {
			const y = d.getFullYear();
			const m = String(d.getMonth()+1).padStart(2,'0');
			const day = String(d.getDate()).padStart(2,'0');
			dates.push(`${y}-${m}-${day}`);
		}
		return dates;
	}

	function renderFeed(trades, symbol) {
		const container = document.getElementById('feed');
		container.innerHTML = '';
		for (const ev of trades.filter(e => e.symbol === symbol)) {
			const side = (ev.order?.side || '').toUpperCase();
			const qty = ev.order?.quantity ?? ev.order?.quote_quantity ?? '?';
			const price = ev.order?.price ?? '-';
			const time = ev.timestamp ? new Date(ev.timestamp).toLocaleString() : '';
			const row = document.createElement('div');
			row.className = 'row';
			row.innerHTML = `
				<div>
					<div class="${side === 'BUY' ? 'buy' : 'sell'}">${side} ${qty}</div>
					<div class="small">${time}</div>
				</div>
				<div>${price}</div>
			`;
			container.appendChild(row);
		}
	}

	function renderCandlesAndTrades(bars, trades, symbol, tf) {
		const b = bars.filter(x => x.symbol === symbol && x.timeframe === tf).map(x => x.bar);
		const x = b.map(v => new Date(v.timestamp));
		const open = b.map(v => v.open);
		const high = b.map(v => v.high);
		const low = b.map(v => v.low);
		const close = b.map(v => v.close);
		const trace = { type: 'candlestick', x, open, high, low, close, increasing: { line: { color: '#4ade80' } }, decreasing: { line: { color: '#f87171' } }, name: 'OHLC' };
		const t = trades.filter(e => e.symbol === symbol && (e.order?.status === 'FILLED'));
		const buys = t.filter(e => (e.order?.side || '').toUpperCase() === 'BUY');
		const sells = t.filter(e => (e.order?.side || '').toUpperCase() === 'SELL');
		const buyTrace = { x: buys.map(e => new Date(e.timestamp)), y: buys.map(e => e.order?.price ?? null), mode: 'markers', name: 'Buys', marker: { color: '#4ade80', size: 8, symbol: 'triangle-up' } };
		const sellTrace = { x: sells.map(e => new Date(e.timestamp)), y: sells.map(e => e.order?.price ?? null), mode: 'markers', name: 'Sells', marker: { color: '#f87171', size: 8, symbol: 'triangle-down' } };
		const layout = { uirevision: 'candles', paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)', margin: { l: 40, r: 20, t: 10, b: 40 }, xaxis: { color: '#9aa3b2' }, yaxis: { color: '#9aa3b2' } };
		Plotly.react('candles', [trace, buyTrace, sellTrace], layout);
	}

	function renderEquityFromAccount(acct) {
		const xs = []; const ys = [];
		for (const a of acct) {
			const eq = a?.account?.equity_quote;
			if (eq == null) continue;
			xs.push(new Date(a.timestamp));
			ys.push(Number(eq));
		}
		if (xs.length === 0) { Plotly.purge('equity_quote'); return; }
		const data = [{ x: xs, y: ys, mode: 'lines', name: 'Equity', line: { color: '#6ea8fe' } }];
		const layout = { uirevision: 'equity', paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)', margin: { l: 40, r: 20, t: 10, b: 40 }, xaxis: { color: '#9aa3b2' }, yaxis: { color: '#9aa3b2' } };
		Plotly.react('equity_quote', data, layout);
	}

	function computeMetrics(trades, bars, symbol, startEquity=10000) {
		const t = trades.filter(e => e.symbol === symbol && (e.order?.status === 'FILLED')).sort((a,b) => (a.timestamp || '').localeCompare(b.timestamp || ''));
		let gross = 0, fees = 0, wins = 0, losses = 0, nClose = 0; let sumWin = 0, sumLoss = 0; let equity = startEquity, peak = startEquity, maxDD = 0; let openQty = 0, entryPrice = null;
		for (const ev of t) { const fills = (ev.execution?.fills || []); for (const f of fills) fees += Number(f.fee_amount || 0) || 0; const realized = ev.pnl?.realized_pnl; if (realized != null) { const r = Number(realized) || 0; gross += r; equity += r; if (r > 0) { wins++; sumWin += r; } else if (r < 0) { losses++; sumLoss += r; } nClose++; openQty = 0; entryPrice = null; } if ((ev.order?.side || '').toUpperCase() === 'BUY' && (ev.pnl?.position_qty_after || 0) > 0 && entryPrice == null) { entryPrice = Number(ev.execution?.average_fill_price ?? ev.order?.price ?? null); openQty = Number(ev.pnl?.position_qty_after ?? ev.execution?.cumulative_qty ?? 0) || 0; } equity -= (fills.reduce((acc, f) => acc + (Number(f.fee_amount || 0) || 0), 0)); if (equity > peak) peak = equity; else { const dd = equity - peak; if (dd < maxDD) maxDD = dd; } }
		let unreal = 0; const b = bars.filter(x => x.symbol === symbol).map(x => x.bar); const lastClose = b.length ? Number(b[b.length - 1].close ?? NaN) : NaN; if (openQty > 0 && Number.isFinite(lastClose) && entryPrice != null) { unreal = (lastClose - Number(entryPrice)) * openQty; equity += unreal; if (equity > peak) peak = equity; else { const dd = equity - peak; if (dd < maxDD) maxDD = dd; } }
		const n = nClose; const pWin = n ? wins / n : null; const avgWin = wins ? (sumWin / wins) : null; const avgLoss = losses ? (sumLoss / losses) : null; const pf = (sumWin > 0 && sumLoss < 0) ? (sumWin / Math.abs(sumLoss)) : null; const expectancy = (pWin != null && avgWin != null && avgLoss != null) ? (pWin * avgWin + (1 - pWin) * avgLoss) : null; return { n, pWin, gross, fees, net: gross - fees, maxDD, avgWin, avgLoss, pf, expectancy, unreal };
	}

	function applyKpisFromSummary(summary) {
		if (!summary) return false; const toNum = v => (v == null ? null : Number(v)); const w = summary.win_rate; document.getElementById('k_trades').textContent = String(summary.trades ?? '-'); document.getElementById('k_win').textContent = (w == null ? '-' : (Number(w) * 100).toFixed(1) + '%'); document.getElementById('k_gross').textContent = (toNum(summary.gross_pnl_quote) ?? 0).toFixed(2); document.getElementById('k_fees').textContent = (toNum(summary.fees_quote) ?? 0).toFixed(2); document.getElementById('k_net').textContent = (toNum(summary.net_pnl_quote) ?? 0).toFixed(2); document.getElementById('k_dd').textContent = (toNum(summary.max_drawdown_quote) ?? 0).toFixed(2); return true;
	}

	async function refresh() {
		const sym = document.getElementById('symbol').value.trim();
		const tf = document.getElementById('tf').value;
		const from = document.getElementById('from').value;
		const to = document.getElementById('to').value;
		const allDates = dateRangeStrings(from, to, 30);
		// Probe only bar files to avoid 404s on trades/account
		const existenceChecks = await Promise.all(allDates.map(async d => {
			const hasBars = await fetchHead(`logs/bars_${sym}_${tf}_${d}.ndjson`);
			return { d, ok: hasBars };
		}));
		const dates = existenceChecks.filter(x => x.ok).map(x => x.d);
		if (dates.length === 0) {
			// Nothing found; fall back to today only to avoid repeated 404s
			const today = new Date();
			const y = today.getFullYear(), m = String(today.getMonth()+1).padStart(2,'0'), day = String(today.getDate()).padStart(2,'0');
			dates.push(`${y}-${m}-${day}`);
		}
		const tradePaths = dates.map(d => `logs/trades_${d}.ndjson`);
		const acctPaths = dates.map(d => `logs/account_${d}.ndjson`);
		const barPaths = dates.map(d => `logs/bars_${sym}_${tf}_${d}.ndjson`);
		const runPaths = dates.map(d => `logs/run_${d}.ndjson`);
		const [trades, bars, acct, runs] = await Promise.all([ fetchMany(tradePaths), fetchMany(barPaths), fetchMany(acctPaths), fetchMany(runPaths) ]);
		// Update session badge with mode if available
		try {
			const latestRun = runs
				.filter(r => (r.config?.symbol || '').toUpperCase() === sym.toUpperCase() && (r.config?.timeframe || '') === tf)
				.sort((a,b) => (a.timestamp || '').localeCompare(b.timestamp || ''))
				.pop();
			if (latestRun) {
				const mode = (latestRun.config?.instrument_mode || 'spot').toUpperCase();
				document.getElementById('session_info').textContent = `${sym} ${tf} [${mode}]`;
			}
		} catch {}
		renderFeed(trades, sym);
		renderCandlesAndTrades(bars, trades, sym, tf);
		renderEquityFromAccount(acct);
		// Compute and populate KPIs
		const m = computeMetrics(trades, bars, sym, 10000);
		document.getElementById('k_trades').textContent = String(m.n ?? '-');
		document.getElementById('k_win').textContent = (m.pWin == null ? '-' : (m.pWin*100).toFixed(1) + '%');
		document.getElementById('k_gross').textContent = (m.gross ?? 0).toFixed(2);
		document.getElementById('k_fees').textContent = (m.fees ?? 0).toFixed(2);
		document.getElementById('k_net').textContent = (m.net ?? 0).toFixed(2);
		document.getElementById('k_dd').textContent = (m.maxDD ?? 0).toFixed(2);
		document.getElementById('k_avg_win').textContent = (m.avgWin == null ? '-' : m.avgWin.toFixed(2));
		document.getElementById('k_avg_loss').textContent = (m.avgLoss == null ? '-' : m.avgLoss.toFixed(2));
		document.getElementById('k_pf').textContent = (m.pf == null ? '-' : m.pf.toFixed(2));
		document.getElementById('k_expect').textContent = (m.expectancy == null ? '-' : m.expectancy.toFixed(2));
		document.getElementById('k_unreal').textContent = (m.unreal ?? 0).toFixed(2);
	}

	document.getElementById('refresh').addEventListener('click', refresh);
	refresh();
	setInterval(refresh, 60*1000);
	</script>
</body>
</html>
