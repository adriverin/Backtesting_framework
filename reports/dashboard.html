<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trading Strategy Dashboard</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    :root {
      --bg: #0c0c0f;
      --bg-elev: #121218ee;
      --surface: #15151d;
      --text: #e7e7ee;
      --muted: #a5a7b1;
      --border: #2a2a36;
      --accent: #5b8cff;
      --accent-2: #71e6b0;
      --shadow: 0 8px 24px rgba(0,0,0,0.45);
    }
    * { box-sizing: border-box; }
    body { background: radial-gradient(1200px 800px at 20% -10%, #171722 0%, transparent 60%), radial-gradient(900px 800px at 100% 0%, #0f0f18 0%, transparent 60%), var(--bg); color: var(--text); font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, sans-serif; -webkit-font-smoothing: antialiased; }
    .wrap { max-width: 1360px; margin: 0 auto; padding: 28px 22px 44px; }
    h1 { font-size: 24px; letter-spacing: 0.2px; font-weight: 800; margin: 0 0 16px; }
    .toolbar { display: flex; flex-wrap: wrap; align-items: center; gap: 12px; margin-bottom: 16px; padding: 10px 12px; border: 1px solid var(--border); border-radius: 14px; background: linear-gradient(180deg, rgba(255,255,255,0.025), rgba(255,255,255,0.02)); box-shadow: var(--shadow); }
    .toolbar input { background: var(--surface); color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 10px 12px; outline: none; transition: border .2s ease, box-shadow .2s ease; }
    .toolbar input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(91,140,255,0.2); }
    .toolbar button { background: linear-gradient(180deg, var(--accent), #3f6fde); color: white; border: none; padding: 10px 14px; border-radius: 10px; cursor: pointer; font-weight: 700; letter-spacing: 0.2px; box-shadow: var(--shadow); transition: transform .05s ease, filter .2s ease; }
    .toolbar button:hover { filter: brightness(1.06); }
    .toolbar button:active { transform: translateY(1px); }
    .tabs { position: sticky; top: 0; z-index: 5; backdrop-filter: saturate(140%) blur(6px); display: flex; gap: 8px; padding: 10px 0; margin: 8px 0 16px; border-bottom: 1px solid var(--border); }
    .tab { padding: 9px 16px; border: 1px solid var(--border); cursor: pointer; border-radius: 999px; background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02)); color: var(--muted); transition: all .2s ease; font-weight: 700; }
    .tab:hover { color: var(--text); }
    .tab.active { background: linear-gradient(180deg, rgba(91,140,255,.18), rgba(91,140,255,.10)); color: var(--text); border-color: #3a3a48; box-shadow: 0 2px 10px rgba(91,140,255,0.2); }
    .panel { display: none; }
    .panel.active { display: block; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 20px; }
    .row { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 20px; }
    @media (max-width: 980px) { .row { grid-template-columns: 1fr; } }
    .col { display: grid; grid-template-columns: 1fr; gap: 20px; }
    .box { border: 1px solid var(--border); padding: 16px; border-radius: 16px; background: linear-gradient(180deg, rgba(255,255,255,0.025), rgba(255,255,255,0.01)); box-shadow: var(--shadow); }
    .box h2 { margin: 0 0 12px; font-size: 13px; color: var(--muted); font-weight: 800; letter-spacing: 0.35px; text-transform: uppercase; display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .mini-btn { background: var(--surface); color: var(--text); border: 1px solid var(--border); border-radius: 999px; padding: 6px 10px; cursor: pointer; font-size: 12px; font-weight: 600; }
    .mini-btn:hover { border-color: #3a3a48; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { border-bottom: 1px solid var(--border); padding: 6px 8px; text-align: left; }
    th { color: var(--muted); font-weight: 600; }
    /* KPI grid */
    .kpis { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 14px; }
    .kpi { background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.015)); border: 1px solid var(--border); border-radius: 14px; padding: 14px; box-shadow: var(--shadow); display: grid; gap: 6px; transition: transform .08s ease, border-color .2s ease, background .2s ease; }
    .kpi:hover { transform: translateY(-1px); border-color: #3a3a48; }
    .kpi .label { color: var(--muted); font-size: 12px; letter-spacing: 0.25px; }
    .kpi .value { font-size: 20px; font-weight: 800; letter-spacing: 0.35px; }
    .kpi .value .unit { font-size: 12px; color: var(--muted); margin-left: 6px; font-weight: 600; }
    .kpi.good .value { color: var(--accent-2); }
    .kpi.bad .value { color: #f27777; }
    /* Ensure Plotly charts expand to container width */
    .js-plotly-plot, .plot-container, .plotly { width: 100% !important; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Strategy Evaluation Dashboard</h1>
    <div class="toolbar">
      <label for="folderInput" style="color: var(--muted); font-weight:600;">Data folder</label>
      <input id="folderInput" type="text" value="example_run" style="width: 320px" />
      <button onclick="loadAll()">Load</button>
      <label for="turnoverMaInput" style="color: var(--muted); font-weight:600; margin-left:12px;">Turnover MA (days)</label>
      <input id="turnoverMaInput" type="number" value="30" min="1" style="width: 90px" />
      <label for="rollingSharpeDaysInput" style="color: var(--muted); font-weight:600; margin-left:12px;">Sharpe (days)</label>
      <input id="rollingSharpeDaysInput" type="number" value="30" min="1" style="width: 90px" />
    </div>

    <div class="tabs">
      <div class="tab active" data-target="is">In-Sample</div>
      <div class="tab" data-target="is_mc">IS Permutations</div>
      <div class="tab" data-target="oos_wf">OOS Walk-Forward</div>
      <div class="tab" data-target="oos_wf_mc">OOS WF Permutations</div>
    </div>

    <div id="is" class="panel active">
      <div class="grid">
        <div class="col">
          <div class="box"><h2>Key Metrics</h2><div id="is_kpis" class="kpis"></div></div>
          <div class="box"><h2>Cumulative Log Returns</h2><div id="is_cum_log"></div></div>
          <div class="box"><h2>Cumulative Simple Returns <button id="toggle_cum_simple" class="mini-btn">Log scale</button></h2><div id="is_cum_simple"></div></div>
          <div class="box"><h2>Underwater (Drawdown)</h2><div id="is_dd"></div></div>
          <div class="box"><h2>Turnover</h2><div id="is_turnover"></div></div>
        </div>
        <div class="row">
          <div class="box"><h2>Rolling Sharpe</h2><div id="is_rolling_sharpe"></div></div>
          <div class="box"><h2>Bar Returns</h2><div id="is_bar_rets"></div></div>
        </div>
        <div class="row">
          <div class="box"><h2>Bar Returns Histogram</h2><div id="is_bar_hist"></div></div>
          <div class="box"><h2>Run Metrics</h2><div id="is_metrics"></div></div>
        </div>
        <div class="col">
          <div class="box"><h2>Run Parameters</h2><div id="is_params"></div></div>
        </div>
      </div>
    </div>

    <div id="is_mc" class="panel">
    <div class="grid">
      <div class="col">
        <div class="box"><h2>Permutation PF (Net) Histogram</h2><div id="is_mc_hist"></div></div>
      </div>
      <div class="row">
        <div class="box"><h2>Run Metrics</h2><div id="is_mc_metrics"></div></div>
        <div class="box"><h2>Run Parameters</h2><div id="is_mc_params"></div></div>
      </div>
    </div>
    </div>

    <div id="oos_wf" class="panel">
    <div class="grid">
      <div class="col">
        <div class="box"><h2>Key Metrics</h2><div id="oos_wf_kpis" class="kpis"></div></div>
        <div class="box"><h2>Cumulative Log Returns</h2><div id="oos_wf_cum_log"></div></div>
        <div class="box"><h2>Cumulative Simple Returns <button id="toggle_oos_cum_simple" class="mini-btn">Log scale</button></h2><div id="oos_wf_cum_simple"></div></div>
        <div class="box"><h2>Underwater (Drawdown)</h2><div id="oos_wf_dd"></div></div>
        <div class="box"><h2>Turnover</h2><div id="oos_wf_turnover"></div></div>
      </div>
      <div class="row">
        <div class="box"><h2>Rolling Sharpe</h2><div id="oos_wf_rolling"></div></div>
        <div class="box"><h2>Bar Returns</h2><div id="oos_wf_bar_rets"></div></div>
      </div>
      <div class="row">
        <div class="box"><h2>Bar Returns Histogram</h2><div id="oos_wf_bar_hist"></div></div>
        <div class="box"><h2>Run Metrics</h2><div id="oos_wf_metrics"></div></div>
      </div>
      <div class="col">
        <div class="box"><h2>Run Parameters</h2><div id="oos_wf_params"></div></div>
      </div>
    </div>
    </div>

    <div id="oos_wf_mc" class="panel">
    <div class="grid">
      <div class="row">
        <div class="box"><h2>Permutation PF (Net) Histogram</h2><div id="oos_wf_mc_hist"></div></div>
        <div class="box"><h2>Run Metrics</h2><div id="oos_wf_mc_metrics"></div></div>
      </div>
      <div class="row">
        <div class="box"><h2>Run Parameters</h2><div id="oos_wf_mc_params"></div></div>
      </div>
    </div>
    </div>
  </div>

  <script>
    // Tab logic
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.target).classList.add('active');
      });
    });

    async function safeFetch(path) {
      // Cache-buster to always fetch the latest JSON
      const url = `${path}?t=${Date.now()}`;
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) return null;
        return await res.json();
      } catch (_) {
        return null;
      }
    }

    function makeTable(containerId, obj) {
      const el = document.getElementById(containerId);
      if (!obj) { el.innerHTML = '<i>No data</i>'; return; }
      const formatVal = (v) => {
        if (v === null || v === undefined) return '-';
        const num = Number(v);
        if (Number.isFinite(num)) {
          // fewer decimals for readability
          if (Math.abs(num) >= 1000) return num.toFixed(0);
          if (Math.abs(num) >= 100) return num.toFixed(1);
          if (Math.abs(num) >= 1) return num.toFixed(2);
          return num.toFixed(4);
        }
        return typeof v === 'object' ? JSON.stringify(v) : String(v);
      };
      const rows = Object.entries(obj).map(([k, v]) => `<tr><th>${k}</th><td>${formatVal(v)}</td></tr>`).join('');
      el.innerHTML = `<table>${rows}</table>`;
    }

    function ensurePanelHasData(panelId, hasData) {
      const panel = document.getElementById(panelId);
      if (!hasData) panel.querySelectorAll('.box').forEach(b => b.innerHTML = '<div class="box"><i>No data</i></div>');
    }

    function renderKpis(containerId, metrics) {
      const el = document.getElementById(containerId);
      if (!metrics) { el.innerHTML = '<i>No data</i>'; return; }
      const fmt = (v, d=2) => Number.isFinite(Number(v)) ? Number(v).toFixed(d) : '-';
      const p = (v) => Number.isFinite(Number(v)) ? `${Number(v).toFixed(2)}%` : '-';
      const intStr = (v) => Number.isFinite(Number(v)) ? String(Math.round(Number(v))) : '-';
      const items = [
        { label: 'PF Gross', value: fmt(metrics.pf_gross, 3), good: Number(metrics.pf_gross) >= 1.2 },
        { label: 'PF Net', value: fmt(metrics.pf_net, 3), good: Number(metrics.pf_net) >= 1.1 },
        { label: 'Sharpe Gross', value: fmt(metrics.sharpe_gross, 2), good: Number(metrics.sharpe_gross) >= 1.0 },
        { label: 'Sharpe Net', value: fmt(metrics.sharpe_net, 2), good: Number(metrics.sharpe_net) >= 1.0 },
        { label: 'Expectancy (Tharp, net)', value: p(metrics.expectancy_tharp_net_pct), good: Number(metrics.expectancy_tharp_net_pct) >= 0 },
        { label: 'Calmar Gross', value: fmt(metrics.calmar_gross, 2), good: Number(metrics.calmar_gross) >= 0.5 },
        { label: 'Calmar Net', value: fmt(metrics.calmar_net, 2), good: Number(metrics.calmar_net) >= 0.5 },
        { label: 'Trades', value: intStr(metrics.num_trades), good: true },
        { label: 'Gross Simple Ret', value: p(metrics.pct_return_simple_gross), good: Number(metrics.pct_return_simple_gross) >= 0 },
        { label: 'Net Simple Ret', value: p(metrics.pct_return_simple_net), good: Number(metrics.pct_return_simple_net) >= 0 },
        { label: 'Win rate (net)', value: p(metrics.win_rate_net_pct), good: Number(metrics.win_rate_net_pct) >= 50 },
        { label: 'Avg win (net)', value: p(metrics.avg_win_net_pct), good: Number(metrics.avg_win_net_pct) > 0 },
        { label: 'Avg loss (net)', value: p(metrics.avg_loss_net_pct), good: Number(metrics.avg_loss_net_pct) > -1 },
        { label: 'Avg Turnover/day', value: fmt(metrics.avg_turnover_per_day, 2), good: true },
        { label: 'Avg Net DD', value: p(metrics.avg_net_drawdown_pct), good: Number(metrics.avg_net_drawdown_pct) >= -10 },
        { label: 'Max Net DD', value: p(metrics.max_net_drawdown_pct), good: Number(metrics.max_net_drawdown_pct) >= -30 },
        { label: 'VaR 95 (per-bar, net)', value: p(metrics.var95_net_pct), good: Number(metrics.var95_net_pct) >= -1 },
        { label: 'CVaR 95 (per-bar, net)', value: p(metrics.cvar95_net_pct), good: Number(metrics.cvar95_net_pct) >= -1 },
      ];
      el.innerHTML = items.map(it => `<div class="kpi ${it.good ? 'good' : 'bad'}"><div class="label">${it.label}</div><div class="value">${it.value}</div></div>`).join('');
    }

    // Helpers for binning and stats
    function toFinite(arr) {
      return (arr || []).filter(v => Number.isFinite(v));
    }
    function quantile(arr, q) {
      const a = toFinite(arr).slice().sort((x, y) => x - y);
      if (a.length === 0) return NaN;
      const pos = (a.length - 1) * q;
      const base = Math.floor(pos);
      const rest = pos - base;
      return a[base + 1] !== undefined ? a[base] + rest * (a[base + 1] - a[base]) : a[base];
    }
    function mean(arr) {
      const a = toFinite(arr);
      if (a.length === 0) return NaN;
      return a.reduce((s, v) => s + v, 0) / a.length;
    }
    function std(arr) {
      const a = toFinite(arr);
      if (a.length < 2) return NaN;
      const m = mean(a);
      const v = a.reduce((s, x) => s + (x - m) * (x - m), 0) / (a.length - 1);
      return Math.sqrt(v);
    }
    // Transform cumulative simple returns [-1, inf) into equity [0, inf)
    function toEquity(arr) {
      return (arr || []).map(v => {
        const num = Number(v);
        if (!Number.isFinite(num)) return 1;
        const e = 1 + num;
        return e < 0 ? 0 : e; // cap at 0 for -100%
      });
    }
    function clampPositive(arr, eps = 1e-9) {
      return (arr || []).map(v => (v <= 0 || !Number.isFinite(v) ? eps : v));
    }
    function barsPerDayFromTimeframe(tf) {
      if (!tf || typeof tf !== 'string') return 24.0;
      const t = tf.toLowerCase().trim();
      if (t.endsWith('m')) {
        const minutes = Number.parseInt(t.slice(0, -1), 10);
        const minutesPerBar = Number.isFinite(minutes) && minutes > 0 ? minutes : 60;
        return (24 * 60) / minutesPerBar;
      }
      if (t.endsWith('h')) {
        const hours = Number.parseInt(t.slice(0, -1), 10);
        const hoursPerBar = Number.isFinite(hours) && hours > 0 ? hours : 1;
        return 24 / hoursPerBar;
      }
      if (t.endsWith('d')) {
        const days = Number.parseInt(t.slice(0, -1), 10);
        const daysPerBar = Number.isFinite(days) && days > 0 ? days : 1;
        return 1 / daysPerBar;
      }
      return 24.0;
    }
    function annualisationFactor(tf) {
      const t = (tf || '').toLowerCase().trim();
      let minutesPerBar = 60;
      if (t.endsWith('m')) minutesPerBar = Math.max(1, Number.parseInt(t.slice(0, -1), 10));
      else if (t.endsWith('h')) minutesPerBar = Math.max(1, Number.parseInt(t.slice(0, -1), 10)) * 60;
      else if (t.endsWith('d')) minutesPerBar = Math.max(1, Number.parseInt(t.slice(0, -1), 10)) * 60 * 24;
      const periodsPerYear = (365 * 24 * 60) / minutesPerBar;
      return Math.sqrt(periodsPerYear);
    }
    function plotIS(data) {
      const has = !!data;
      ensurePanelHasData('is', has);
      if (!has) return;

      const ts = data.series.timestamps;
      const stratGross = data.series.strategy.gross;
      const stratNet = data.series.strategy.net;
      const asset = data.series.asset;
      const m = data.metrics || {};

      // Enrich metrics with Max Net Drawdown computed from drawdown series if not provided
      try {
        const dd = toFinite(stratNet && stratNet.drawdown ? stratNet.drawdown : []);
        if (dd.length > 0) {
          const mdd = Math.min.apply(null, dd);
          if (!Number.isFinite(Number(m.max_net_drawdown_pct))) {
            m.max_net_drawdown_pct = mdd * 100.0;
          }
        }
      } catch (_) { /* noop */ }

      Plotly.newPlot('is_cum_log', [
        { x: ts, y: stratGross.cum_log, mode: 'lines', name: 'Strategy Gross (log)' },
        { x: ts, y: stratNet.cum_log, mode: 'lines', name: 'Strategy Net (log)' },
        { x: ts, y: asset.cum_log, mode: 'lines', name: 'Asset (log)', line: { dash: 'dot' } },
      ], {
        template: 'plotly_dark', height: 460, margin: { t: 30 },
        xaxis: { title: 'Time' }, yaxis: { title: 'Cumulative log return' },
        annotations: [{
          text: `Gross PF: ${Number(m.pf_gross).toFixed(3)}\nNet PF: ${Number(m.pf_net).toFixed(3)}\nGross Sharpe: ${Number(m.sharpe_gross).toFixed(3)}\nNet Sharpe: ${Number(m.sharpe_net).toFixed(3)}\nGross Log Ret: ${Number(m.pct_return_log_gross).toFixed(2)}%\nNet Log Ret: ${Number(m.pct_return_log_net).toFixed(2)}%`,
          xref: 'paper', yref: 'paper', x: 1, y: 1, xanchor: 'right', yanchor: 'top', align: 'left',
          bgcolor: '#111', bordercolor: '#444', borderwidth: 1, opacity: 0.9, font: { size: 10 }
        }]
      });

      const equityGross = (stratGross.equity && stratGross.equity.length) ? stratGross.equity : toEquity(stratGross.cum_simple);
      const equityNet = (stratNet.equity && stratNet.equity.length) ? stratNet.equity : toEquity(stratNet.cum_simple);
      const equityAsset = (asset.equity && asset.equity.length) ? asset.equity : toEquity(asset.cum_simple);
      // Enrich KPIs: Expectancy (Tharp, net), Calmar ratios, Trades
      try {
        const wr = Number(m.win_rate_net_pct);
        const aw = Number(m.avg_win_net_pct);
        const al = Number(m.avg_loss_net_pct);
        if (Number.isFinite(wr) && Number.isFinite(aw) && Number.isFinite(al)) {
          const wrFrac = Math.max(0, Math.min(1, wr / 100.0));
          m.expectancy_tharp_net_pct = wrFrac * aw + (1 - wrFrac) * al;
        }
      } catch (_) { /* noop */ }
      try {
        const t0 = ts && ts.length ? new Date(ts[0]).getTime() : NaN;
        const t1 = ts && ts.length ? new Date(ts[ts.length - 1]).getTime() : NaN;
        const years = Number.isFinite(t0) && Number.isFinite(t1) && t1 > t0 ? (t1 - t0) / (365.25 * 24 * 3600 * 1000) : NaN;
        const egLast = equityGross && equityGross.length ? Number(equityGross[equityGross.length - 1]) : NaN;
        const enLast = equityNet && equityNet.length ? Number(equityNet[equityNet.length - 1]) : NaN;
        const mddGross = stratGross && Array.isArray(stratGross.drawdown) && stratGross.drawdown.length ? Math.abs(Math.min.apply(null, stratGross.drawdown.map(Number))) : NaN;
        const mddNet = stratNet && Array.isArray(stratNet.drawdown) && stratNet.drawdown.length ? Math.abs(Math.min.apply(null, stratNet.drawdown.map(Number))) : NaN;
        if (Number.isFinite(years) && years > 0 && Number.isFinite(egLast) && egLast > 0 && Number.isFinite(mddGross) && mddGross > 0) {
          const cagrGross = Math.pow(egLast, 1 / years) - 1;
          m.calmar_gross = cagrGross / mddGross;
        }
        if (Number.isFinite(years) && years > 0 && Number.isFinite(enLast) && enLast > 0 && Number.isFinite(mddNet) && mddNet > 0) {
          const cagrNet = Math.pow(enLast, 1 / years) - 1;
          m.calmar_net = cagrNet / mddNet;
        }
      } catch (_) { /* noop */ }
      try {
        const assetSimple = (asset && Array.isArray(asset.ret_simple)) ? asset.ret_simple.map(Number) : [];
        const grossLog = (stratGross && Array.isArray(stratGross.ret_log)) ? stratGross.ret_log.map(Number) : [];
        const grossSimple = grossLog.map(v => Number.isFinite(v) ? Math.expm1(v) : 0);
        const n = Math.min(assetSimple.length, grossSimple.length);
        let lastSign = 0, segments = 0;
        const EPS_DEN = 1e-9, EPS_W = 1e-3, EPS_SMPL = 1e-9;
        for (let i = 0; i < n; i++) {
          const den = assetSimple[i];
          const sg = grossSimple[i];
          let sign = 0;
          if (Number.isFinite(den) && Math.abs(den) >= EPS_DEN) {
            const w = sg / den;
            if (Number.isFinite(w) && Math.abs(w) > EPS_W) sign = w > 0 ? 1 : -1;
          } else if (Number.isFinite(sg) && Math.abs(sg) < EPS_SMPL) {
            sign = 0; // flat bar
          }
          if (sign !== 0 && sign !== lastSign) segments += 1; // entry or reversal
          if (sign === 0) lastSign = 0; else lastSign = sign;
        }
        if (segments > 0) m.num_trades = segments;
      } catch (_) { /* noop */ }
      const cumSimpleTraces = [
        { x: ts, y: equityGross, mode: 'lines', name: 'Strategy Gross (equity)' },
        { x: ts, y: equityNet, mode: 'lines', name: 'Strategy Net (equity)' },
        { x: ts, y: equityAsset, mode: 'lines', name: 'Asset (equity)', line: { dash: 'dot' } },
      ];
      const cumSimpleLayout = { template: 'plotly_dark', height: 460, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Equity (start=1, min=0)' } };
      Plotly.newPlot('is_cum_simple', cumSimpleTraces, cumSimpleLayout);
      // store arrays for toggling
      const cumEl = document.getElementById('is_cum_simple');
      cumEl._equityGross = equityGross;
      cumEl._equityNet = equityNet;
      cumEl._equityAsset = equityAsset;

      const avgNetDDPct = Number(m.avg_net_drawdown_pct);
      const avgNetDD = Number.isFinite(avgNetDDPct) ? avgNetDDPct / 100.0 : null;
      const ddTraces = [
        { x: ts, y: stratGross.drawdown, mode: 'lines', name: 'Gross DD', line: { color: '#5b8cff' }, fill: 'tozeroy', fillcolor: 'rgba(91,140,255,0.18)' },
        { x: ts, y: stratNet.drawdown, mode: 'lines', name: 'Net DD', line: { color: '#ff9f43' }, fill: 'tozeroy', fillcolor: 'rgba(255,159,67,0.18)' },
      ];
      const ddLayout = { template: 'plotly_dark', height: 460, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Drawdown' } };
      if (avgNetDD !== null) {
        ddLayout.shapes = [ { type: 'line', x0: ts[0], x1: ts[ts.length-1], y0: avgNetDD, y1: avgNetDD, xref: 'x', yref: 'y', line: { color: '#ff9f43', width: 2, dash: 'dot' } } ];
        ddLayout.annotations = [ { x: ts[ts.length-1], y: avgNetDD, xref: 'x', yref: 'y', xanchor: 'right', yanchor: 'bottom', showarrow: false, text: `Avg Net DD: ${avgNetDDPct.toFixed(2)}%`, font: { size: 12, color: '#ff9f43' }, bgcolor: 'rgba(17,17,17,0.6)', bordercolor: '#333', borderwidth: 1 } ];
      }
      Plotly.newPlot('is_dd', ddTraces, ddLayout);

      Plotly.newPlot('is_rolling_sharpe', [
        { x: ts, y: stratGross.rolling_sharpe, mode: 'lines', name: 'Gross' },
        { x: ts, y: stratNet.rolling_sharpe, mode: 'lines', name: 'Net' },
      ], { template: 'plotly_dark', height: 360, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Annualized Sharpe' } });
      const sharpeInputEl = document.getElementById('rollingSharpeDaysInput');
      if (sharpeInputEl && !sharpeInputEl.dataset.wired) {
        sharpeInputEl.dataset.wired = '1';
        const ann = annualisationFactor((data.params && data.params.timeframe) || '1h');
        const bpdLocal = barsPerDayFromTimeframe((data.params && data.params.timeframe) || '1h');
        function rollingSharpe(arr, n) {
          const out = new Array(arr.length).fill(null);
          let sum = 0, sumSq = 0;
          for (let i = 0; i < arr.length; i++) {
            const v = Number(arr[i]);
            const val = Number.isFinite(v) ? v : 0;
            sum += val; sumSq += val * val;
            if (i >= n) {
              const drop = Number(arr[i - n]);
              const dv = Number.isFinite(drop) ? drop : 0;
              sum -= dv; sumSq -= dv * dv;
            }
            if (i >= n - 1) {
              const mean = sum / n;
              const variance = Math.max(0, (sumSq - n * mean * mean) / (n - 1));
              const sd = Math.sqrt(variance);
              out[i] = sd > 0 ? (mean / sd) * ann : null;
            }
          }
          return out;
        }
        sharpeInputEl.addEventListener('input', () => {
          let d = parseInt(sharpeInputEl.value || '0', 10);
          if (!Number.isFinite(d) || d <= 0) d = 1;
          const nBars = Math.max(1, Math.round(d * bpdLocal));
          const g = rollingSharpe(stratGross.ret_log || [], nBars);
          const n = rollingSharpe(stratNet.ret_log || [], nBars);
          Plotly.react('is_rolling_sharpe', [
            { x: ts, y: g, mode: 'lines', name: 'Gross' },
            { x: ts, y: n, mode: 'lines', name: 'Net' },
          ], { template: 'plotly_dark', height: 360, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Annualized Sharpe' } });
        });
      }

      Plotly.newPlot('is_bar_rets', [
        { x: ts, y: stratGross.ret_log, mode: 'lines', name: 'Gross bar log ret', hovertemplate: 'Time: %{x}<br>Log return: %{y:.6f}<extra>Gross</extra>' },
        { x: ts, y: stratNet.ret_log, mode: 'lines', name: 'Net bar log ret', hovertemplate: 'Time: %{x}<br>Log return: %{y:.6f}<extra>Net</extra>' },
      ], { template: 'plotly_dark', height: 360, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Bar log return' }, shapes: [ { type: 'line', x0: ts[0], x1: ts[ts.length-1], y0: 0, y1: 0, xref: 'x', yref: 'y', line: { color: '#777', dash: 'dot' } } ] });

      const grossR = toFinite(stratGross.ret_log);
      const netR = toFinite(stratNet.ret_log);
      const combined = grossR.concat(netR);
      let lo = quantile(combined, 0.01);
      let hi = quantile(combined, 0.99);
      if (!Number.isFinite(lo) || !Number.isFinite(hi) || lo === hi) { lo = -0.01; hi = 0.01; }
      const binSize = Math.max((hi - lo) / 80, 1e-6);
      const muGross = mean(grossR), sdGross = std(grossR);
      const muNet = mean(netR), sdNet = std(netR);

      Plotly.newPlot('is_bar_hist', [
        { x: grossR, type: 'histogram', opacity: 0.6, name: 'Gross', histnorm: 'probability density', xbins: { start: lo, end: hi, size: binSize }, hovertemplate: 'Return: %{x:.6f}<br>Density: %{y:.3f}<extra>Gross</extra>' },
        { x: netR, type: 'histogram', opacity: 0.6, name: 'Net', histnorm: 'probability density', xbins: { start: lo, end: hi, size: binSize }, hovertemplate: 'Return: %{x:.6f}<br>Density: %{y:.3f}<extra>Net</extra>' },
      ], { template: 'plotly_dark', barmode: 'overlay', height: 360, margin: { t: 30 }, xaxis: { title: 'Bar log return', range: [lo, hi] }, yaxis: { title: 'Density' }, shapes: [ { type: 'line', x0: 0, x1: 0, y0: 0, y1: 1, xref: 'x', yref: 'paper', line: { color: '#777', dash: 'dot' } } ], annotations: [{ text: `Gross μ=${Number(muGross).toExponential(2)}, σ=${Number(sdGross).toExponential(2)}\nNet μ=${Number(muNet).toExponential(2)}, σ=${Number(sdNet).toExponential(2)}`, xref: 'paper', yref: 'paper', x: 1, y: 1, xanchor: 'right', yanchor: 'top', align: 'left', bgcolor: '#111', bordercolor: '#444', borderwidth: 1, opacity: 0.9, font: { size: 10 } }] });

      makeTable('is_metrics', data.metrics);
      // also surface core win/loss stats near run metrics if present
      // no structural change needed as makeTable renders all metrics
      makeTable('is_params', data.params);
      renderKpis('is_kpis', m);

      // Turnover plot
      function movingAvg(arr, n) {
        const out = new Array(arr.length).fill(null);
        let sum = 0;
        for (let i = 0; i < arr.length; i++) {
          const v = Number(arr[i]);
          sum += Number.isFinite(v) ? v : 0;
          if (i >= n) {
            const drop = Number(arr[i - n]);
            sum -= Number.isFinite(drop) ? drop : 0;
          }
          if (i >= n - 1) out[i] = sum / n;
        }
        return out;
      }
      const turnover = (data.series && data.series.turnover) || [];
      const tfStr = (data.params && data.params.timeframe) || '1h';
      const bpd = barsPerDayFromTimeframe(tfStr);
      let maDays = parseInt((document.getElementById('turnoverMaInput') && document.getElementById('turnoverMaInput').value) || '0', 10);
      if (!Number.isFinite(maDays) || maDays <= 0) {
        maDays = 30;
      }
      const maBars = Math.max(1, Math.round(maDays * bpd));
      const turnoverMA = movingAvg(turnover, maBars);
      Plotly.newPlot('is_turnover', [
        { x: ts, y: turnover, mode: 'lines', name: 'Turnover (per bar)', line: { color: '#888', width: 1 }, opacity: 0.6 },
        { x: ts, y: turnoverMA, mode: 'lines', name: `Turnover MA(${maDays}d)`, line: { color: '#5b8cff', width: 2 } },
      ], { template: 'plotly_dark', height: 360, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Turnover' } });

      const maInputEl = document.getElementById('turnoverMaInput');
      if (maInputEl && !maInputEl.dataset.wired) {
        maInputEl.dataset.wired = '1';
        maInputEl.addEventListener('input', () => {
          let d = parseInt(maInputEl.value || '0', 10);
          if (!Number.isFinite(d) || d <= 0) d = 1;
          const nBars = Math.max(1, Math.round(d * bpd));
          const ma = movingAvg(turnover, nBars);
          Plotly.react('is_turnover', [
            { x: ts, y: turnover, mode: 'lines', name: 'Turnover (per bar)', line: { color: '#888', width: 1 }, opacity: 0.6 },
            { x: ts, y: ma, mode: 'lines', name: `Turnover MA(${d}d)`, line: { color: '#5b8cff', width: 2 } },
          ], { template: 'plotly_dark', height: 360, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Turnover' } });
        });
      }

      // Toggle button for log/linear scale on cumulative simple returns
      const toggleBtn = document.getElementById('toggle_cum_simple');
      if (toggleBtn && !toggleBtn.dataset.wired) {
        toggleBtn.dataset.wired = '1';
        toggleBtn.dataset.scale = 'linear';
        toggleBtn.addEventListener('click', () => {
          const next = toggleBtn.dataset.scale === 'linear' ? 'log' : 'linear';
          const el = document.getElementById('is_cum_simple');
          if (next === 'log') {
            Plotly.restyle('is_cum_simple', { y: [
              clampPositive(el._equityGross),
              clampPositive(el._equityNet),
              clampPositive(el._equityAsset)
            ]});
          } else {
            Plotly.restyle('is_cum_simple', { y: [
              el._equityGross,
              el._equityNet,
              el._equityAsset
            ]});
          }
          Plotly.relayout('is_cum_simple', { 'yaxis.type': next });
          toggleBtn.dataset.scale = next;
          toggleBtn.textContent = next === 'linear' ? 'Log scale' : 'Linear scale';
        });
      }
    }

    function plotISMC(data) {
      const has = !!data;
      ensurePanelHasData('is_mc', has);
      if (!has) return;
      // Render tables first so they show even if chart errors
      makeTable('is_mc_metrics', data.metrics);
      makeTable('is_mc_params', data.params);

      const pfNet = data.metrics && Number.isFinite(Number(data.metrics.pf_net)) ? Number(data.metrics.pf_net) : null;
      const pVal = data.metrics && Number.isFinite(Number(data.metrics.p_value_net)) ? Number(data.metrics.p_value_net) : null;
      const nPerm = (data.params && Number.isFinite(Number(data.params.n_perm)) ? Number(data.params.n_perm) : null);
      const legendName = (pfNet !== null && pVal !== null) ? `Real (net) PF = ${pfNet.toFixed(3)} | p = ${pVal.toFixed(3)}` : 'Real (net) PF';

      const darkBg = '#0c0c0f';
      const darkBorder = '#2a2a36';

      const series = (data && data.series) || {};
      const perms = toFinite(series.permutation_pfs_net || []);
      const bins = Math.max(12, Math.floor(perms.length / 4));
      const histTrace = {
        x: perms,
        type: 'histogram',
        name: 'Perm Net PF',
        marker: { color: 'rgba(91,140,255,0.75)', line: { color: 'rgba(255,255,255,0.15)', width: 1 } },
        opacity: 0.95,
        nbinsx: bins,
        hovertemplate: 'PF: %{x:.3f}<br>Count: %{y}<extra></extra>'
      };
      const traces = [histTrace];
      if (pfNet !== null) {
        traces.push({ x: [pfNet, pfNet], y: [0, 1], mode: 'lines', name: legendName, line: { color: '#ff6b6b', width: 2 }, visible: 'legendonly' });
      }
      const layout = {
        template: 'plotly_dark', height: 380, margin: { t: 30, r: 10, l: 50, b: 40 },
        // paper_bgcolor: darkBg,
        // plot_bgcolor: darkBg,
        xaxis: { title: 'Net Profit Factor (Permutation)', gridcolor: '#2a2a36' },
        yaxis: { title: 'Count', gridcolor: '#2a2a36' },
        bargap: 0.05,
      };
      const N = nPerm !== null ? nPerm : perms.length;
      layout.title = `IS Permutations (Net PF, p=${pVal !== null ? pVal.toFixed(3) : '?'}, N=${N})`;
      if (pfNet !== null) {
        layout.shapes = [ { type: 'line', x0: pfNet, x1: pfNet, y0: 0, y1: 1, xref: 'x', yref: 'paper', line: { color: '#ff6b6b', width: 2 } } ];
        layout.annotations = [ { x: pfNet, y: 1, xref: 'x', yref: 'paper', yanchor: 'bottom', showarrow: false, text: legendName, font: { size: 12, color: '#ff9b9b' }, bgcolor: 'rgba(17,17,17,0.6)', bordercolor: '#333', borderwidth: 1, align: 'left' } ];
      }
      renderResponsivePlot('is_mc_hist', traces, layout);
      setupResize('is_mc_hist');
    }

    function plotOOSWF(data) {
      const has = !!data;
      ensurePanelHasData('oos_wf', has);
      if (!has) return;

      const ts = data.series.timestamps;
      const stratGross = data.series.strategy.gross;
      const stratNet = data.series.strategy.net;
      const m = data.metrics || {};

      // KPIs will be rendered after enrichment below

      // Cumulative log
      renderResponsivePlot('oos_wf_cum_log', [
        { x: ts, y: stratGross.cum_log, mode: 'lines', name: 'Strategy Gross (log)' },
        { x: ts, y: stratNet.cum_log, mode: 'lines', name: 'Strategy Net (log)' },
        { x: ts, y: (data.series.asset && data.series.asset.cum_log) || [], mode: 'lines', name: 'Asset (log)', line: { dash: 'dot' } },
      ], { template: 'plotly_dark', height: 460, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Cumulative log return' } });
      setupResize('oos_wf_cum_log');

      // Cumulative simple (equity)
      const equityGross = (stratGross.equity && stratGross.equity.length) ? stratGross.equity : toEquity(stratGross.cum_simple);
      const equityNet = (stratNet.equity && stratNet.equity.length) ? stratNet.equity : toEquity(stratNet.cum_simple);
      const equityAsset = (data.series.asset && data.series.asset.equity && data.series.asset.equity.length) ? data.series.asset.equity : toEquity((data.series.asset && data.series.asset.cum_simple) || []);
      const cumSimpleTraces = [
        { x: ts, y: equityGross, mode: 'lines', name: 'Strategy Gross (equity)' },
        { x: ts, y: equityNet, mode: 'lines', name: 'Strategy Net (equity)' },
        { x: ts, y: equityAsset, mode: 'lines', name: 'Asset (equity)', line: { dash: 'dot' } },
      ];
      const cumSimpleLayout = { template: 'plotly_dark', height: 460, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Equity (start=1, min=0)' } };
      renderResponsivePlot('oos_wf_cum_simple', cumSimpleTraces, cumSimpleLayout);
      setupResize('oos_wf_cum_simple');
      const oosCumEl = document.getElementById('oos_wf_cum_simple');
      oosCumEl._equityGross = equityGross;
      oosCumEl._equityNet = equityNet;
      oosCumEl._equityAsset = equityAsset;

      // Drawdown
      renderResponsivePlot('oos_wf_dd', [
        { x: ts, y: stratGross.drawdown, mode: 'lines', name: 'Gross DD', line: { color: '#5b8cff' }, fill: 'tozeroy', fillcolor: 'rgba(91,140,255,0.18)' },
        { x: ts, y: stratNet.drawdown, mode: 'lines', name: 'Net DD', line: { color: '#ff9f43' }, fill: 'tozeroy', fillcolor: 'rgba(255,159,67,0.18)' },
      ], { template: 'plotly_dark', height: 460, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Drawdown' } });
      setupResize('oos_wf_dd');

      // Enrich KPIs: Expectancy (Tharp, net), Calmar ratios, Trades
      try {
        const wr = Number(m.win_rate_net_pct);
        const aw = Number(m.avg_win_net_pct);
        const al = Number(m.avg_loss_net_pct);
        if (Number.isFinite(wr) && Number.isFinite(aw) && Number.isFinite(al)) {
          const wrFrac = Math.max(0, Math.min(1, wr / 100.0));
          m.expectancy_tharp_net_pct = wrFrac * aw + (1 - wrFrac) * al;
        }
      } catch (_) { /* noop */ }
      try {
        const t0 = ts && ts.length ? new Date(ts[0]).getTime() : NaN;
        const t1 = ts && ts.length ? new Date(ts[ts.length - 1]).getTime() : NaN;
        const years = Number.isFinite(t0) && Number.isFinite(t1) && t1 > t0 ? (t1 - t0) / (365.25 * 24 * 3600 * 1000) : NaN;
        const egLast = equityGross && equityGross.length ? Number(equityGross[equityGross.length - 1]) : NaN;
        const enLast = equityNet && equityNet.length ? Number(equityNet[equityNet.length - 1]) : NaN;
        const mddGross = stratGross && Array.isArray(stratGross.drawdown) && stratGross.drawdown.length ? Math.abs(Math.min.apply(null, stratGross.drawdown.map(Number))) : NaN;
        const mddNet = stratNet && Array.isArray(stratNet.drawdown) && stratNet.drawdown.length ? Math.abs(Math.min.apply(null, stratNet.drawdown.map(Number))) : NaN;
        if (Number.isFinite(years) && years > 0 && Number.isFinite(egLast) && egLast > 0 && Number.isFinite(mddGross) && mddGross > 0) {
          const cagrGross = Math.pow(egLast, 1 / years) - 1;
          m.calmar_gross = cagrGross / mddGross;
        }
        if (Number.isFinite(years) && years > 0 && Number.isFinite(enLast) && enLast > 0 && Number.isFinite(mddNet) && mddNet > 0) {
          const cagrNet = Math.pow(enLast, 1 / years) - 1;
          m.calmar_net = cagrNet / mddNet;
        }
      } catch (_) { /* noop */ }
      try {
        const assetSimple = (data.series && data.series.asset && Array.isArray(data.series.asset.ret_simple)) ? data.series.asset.ret_simple.map(Number) : [];
        const grossLog = (stratGross && Array.isArray(stratGross.ret_log)) ? stratGross.ret_log.map(Number) : [];
        const grossSimple = grossLog.map(v => Number.isFinite(v) ? Math.expm1(v) : 0);
        const n = Math.min(assetSimple.length, grossSimple.length);
        let lastSign = 0, segments = 0;
        const EPS_DEN = 1e-9, EPS_W = 1e-3, EPS_SMPL = 1e-9;
        for (let i = 0; i < n; i++) {
          const den = assetSimple[i];
          const sg = grossSimple[i];
          let sign = 0;
          if (Number.isFinite(den) && Math.abs(den) >= EPS_DEN) {
            const w = sg / den;
            if (Number.isFinite(w) && Math.abs(w) > EPS_W) sign = w > 0 ? 1 : -1;
          } else if (Number.isFinite(sg) && Math.abs(sg) < EPS_SMPL) {
            sign = 0;
          }
          if (sign !== 0 && sign !== lastSign) segments += 1;
          if (sign === 0) lastSign = 0; else lastSign = sign;
        }
        if (segments > 0) m.num_trades = segments;
      } catch (_) { /* noop */ }

      // Try to override with exact trade count from CSV if available
      try {
        const folder = (window && window._currentFolder) ? window._currentFolder : null;
        if (folder) {
          fetch(`${folder}/oos_wf_trades.csv?t=${Date.now()}`)
            .then(r => r.ok ? r.text() : Promise.reject(new Error('no csv')))
            .then(txt => {
              const lines = (txt || '').trim().split(/\r?\n/);
              const count = lines.length > 1 ? (lines.length - 1) : 0; // minus header
              if (count > 0) {
                m.num_trades = count;
                renderKpis('oos_wf_kpis', m);
              }
            })
            .catch(() => {});
        }
      } catch (_) { /* noop */ }

      // KPIs (after enrichment; CSV override may update it again asynchronously)
      renderKpis('oos_wf_kpis', m);

      // Rolling Sharpe
      renderResponsivePlot('oos_wf_rolling', [
        { x: ts, y: stratGross.rolling_sharpe, mode: 'lines', name: 'Gross' },
        { x: ts, y: stratNet.rolling_sharpe, mode: 'lines', name: 'Net' },
      ], { template: 'plotly_dark', height: 360, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Annualized Sharpe' } });
      setupResize('oos_wf_rolling');

      // Bar returns
      renderResponsivePlot('oos_wf_bar_rets', [
        { x: ts, y: stratGross.ret_log, mode: 'lines', name: 'Gross bar log ret', hovertemplate: 'Time: %{x}<br>Log return: %{y:.6f}<extra>Gross</extra>' },
        { x: ts, y: stratNet.ret_log, mode: 'lines', name: 'Net bar log ret', hovertemplate: 'Time: %{x}<br>Log return: %{y:.6f}<extra>Net</extra>' },
      ], { template: 'plotly_dark', height: 360, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Bar log return' }, shapes: [ { type: 'line', x0: ts[0], x1: ts[ts.length-1], y0: 0, y1: 0, xref: 'x', yref: 'y', line: { color: '#777', dash: 'dot' } } ] });
      setupResize('oos_wf_bar_rets');

      // Histogram, same binning logic
      const grossR = toFinite(stratGross.ret_log);
      const netR = toFinite(stratNet.ret_log);
      const combined = grossR.concat(netR);
      let lo = quantile(combined, 0.01);
      let hi = quantile(combined, 0.99);
      if (!Number.isFinite(lo) || !Number.isFinite(hi) || lo === hi) { lo = -0.01; hi = 0.01; }
      const binSize = Math.max((hi - lo) / 80, 1e-6);
      const muGross = mean(grossR), sdGross = std(grossR);
      const muNet = mean(netR), sdNet = std(netR);
      renderResponsivePlot('oos_wf_bar_hist', [
        { x: grossR, type: 'histogram', opacity: 0.6, name: 'Gross', histnorm: 'probability density', xbins: { start: lo, end: hi, size: binSize }, hovertemplate: 'Return: %{x:.6f}<br>Density: %{y:.3f}<extra>Gross</extra>' },
        { x: netR, type: 'histogram', opacity: 0.6, name: 'Net', histnorm: 'probability density', xbins: { start: lo, end: hi, size: binSize }, hovertemplate: 'Return: %{x:.6f}<br>Density: %{y:.3f}<extra>Net</extra>' },
      ], { template: 'plotly_dark', barmode: 'overlay', height: 360, margin: { t: 30 }, xaxis: { title: 'Bar log return', range: [lo, hi] }, yaxis: { title: 'Density' }, shapes: [ { type: 'line', x0: 0, x1: 0, y0: 0, y1: 1, xref: 'x', yref: 'paper', line: { color: '#777', dash: 'dot' } } ], annotations: [{ text: `Gross μ=${Number(muGross).toExponential(2)}, σ=${Number(sdGross).toExponential(2)}\nNet μ=${Number(muNet).toExponential(2)}, σ=${Number(sdNet).toExponential(2)}`, xref: 'paper', yref: 'paper', x: 1, y: 1, xanchor: 'right', yanchor: 'top', align: 'left', bgcolor: '#111', bordercolor: '#444', borderwidth: 1, opacity: 0.9, font: { size: 10 } }] });
      setupResize('oos_wf_bar_hist');

      // Turnover with MA control
      function movingAvg(arr, n) {
        const out = new Array(arr.length).fill(null);
        let sum = 0;
        for (let i = 0; i < arr.length; i++) {
          const v = Number(arr[i]);
          sum += Number.isFinite(v) ? v : 0;
          if (i >= n) {
            const drop = Number(arr[i - n]);
            sum -= Number.isFinite(drop) ? drop : 0;
          }
          if (i >= n - 1) out[i] = sum / n;
        }
        return out;
      }
      const turnover = (data.series && data.series.turnover) || [];
      const tfStr = (data.params && data.params.timeframe) || '1h';
      const bpd = barsPerDayFromTimeframe(tfStr);
      let maDays = parseInt((document.getElementById('turnoverMaInput') && document.getElementById('turnoverMaInput').value) || '0', 10);
      if (!Number.isFinite(maDays) || maDays <= 0) { maDays = 30; }
      const maBars = Math.max(1, Math.round(maDays * bpd));
      const turnoverMA = movingAvg(turnover, maBars);
      renderResponsivePlot('oos_wf_turnover', [
        { x: ts, y: turnover, mode: 'lines', name: 'Turnover (per bar)', line: { color: '#888', width: 1 }, opacity: 0.6 },
        { x: ts, y: turnoverMA, mode: 'lines', name: `Turnover MA(${maDays}d)`, line: { color: '#5b8cff', width: 2 } },
      ], { template: 'plotly_dark', height: 360, margin: { t: 30 }, xaxis: { title: 'Time' }, yaxis: { title: 'Turnover' } });
      setupResize('oos_wf_turnover');

      // Tables
      makeTable('oos_wf_metrics', data.metrics);
      makeTable('oos_wf_params', data.params);

      // Toggle button wiring for OOS cumulative simple plot
      const toggleBtn = document.getElementById('toggle_oos_cum_simple');
      if (toggleBtn && !toggleBtn.dataset.wired) {
        toggleBtn.dataset.wired = '1';
        toggleBtn.dataset.scale = 'linear';
        toggleBtn.addEventListener('click', () => {
          const next = toggleBtn.dataset.scale === 'linear' ? 'log' : 'linear';
          const el = document.getElementById('oos_wf_cum_simple');
          if (next === 'log') {
            Plotly.restyle('oos_wf_cum_simple', { y: [
              clampPositive(el._equityGross),
              clampPositive(el._equityNet),
              clampPositive(el._equityAsset)
            ]});
          } else {
            Plotly.restyle('oos_wf_cum_simple', { y: [
              el._equityGross,
              el._equityNet,
              el._equityAsset
            ]});
          }
          Plotly.relayout('oos_wf_cum_simple', { 'yaxis.type': next });
          toggleBtn.dataset.scale = next;
          toggleBtn.textContent = next === 'linear' ? 'Log scale' : 'Linear scale';
        });
      }
    }

    function plotOOSWFMC(data) {
      const has = !!data;
      ensurePanelHasData('oos_wf_mc', has);
      if (!has) return;
      const pfNet = data.metrics && Number.isFinite(Number(data.metrics.pf_net)) ? Number(data.metrics.pf_net) : null;
      const pVal = data.metrics && Number.isFinite(Number(data.metrics.p_value_net)) ? Number(data.metrics.p_value_net) : null;
      const legendName = (pfNet !== null && pVal !== null) ? `Real (net) PF = ${pfNet.toFixed(3)} | p = ${pVal.toFixed(3)}` : 'Real (net) PF';

      const perms = toFinite((data.series && data.series.permutation_pfs_net) || []);
      const nPerm = (data.params && Number.isFinite(Number(data.params.n_perm)) ? Number(data.params.n_perm) : null);
      const bins = Math.max(12, Math.floor(perms.length / 4));
      const histTrace = {
        x: perms,
        type: 'histogram',
        name: 'Perm Net PF',
        marker: { color: 'rgba(91,140,255,0.75)', line: { color: 'rgba(255,255,255,0.15)', width: 1 } },
        opacity: 0.95,
        nbinsx: bins,
        hovertemplate: 'PF: %{x:.3f}<br>Count: %{y}<extra></extra>'
      };
      const traces = [histTrace];
      if (pfNet !== null) {
        traces.push({ x: [pfNet, pfNet], y: [0, 1], mode: 'lines', name: legendName, line: { color: '#ff6b6b', width: 2 }, visible: 'legendonly' });
      }
      const layout = {
        template: 'plotly_dark', height: 380, margin: { t: 30, r: 10, l: 50, b: 40 },
        xaxis: { title: 'Net Profit Factor (Permutation)', gridcolor: '#2a2a36' },
        yaxis: { title: 'Count', gridcolor: '#2a2a36' },
        bargap: 0.05,
      };
      const N = nPerm !== null ? nPerm : perms.length;
      layout.title = `OOS WF Permutations (Net PF, p=${pVal !== null ? pVal.toFixed(3) : '?'}, N=${N})`;
      if (pfNet !== null) {
        layout.shapes = [ { type: 'line', x0: pfNet, x1: pfNet, y0: 0, y1: 1, xref: 'x', yref: 'paper', line: { color: '#ff6b6b', width: 2 } } ];
        layout.annotations = [ { x: pfNet, y: 1, xref: 'x', yref: 'paper', yanchor: 'bottom', showarrow: false, text: legendName, font: { size: 12, color: '#ff9b9b' }, bgcolor: 'rgba(17,17,17,0.6)', bordercolor: '#333', borderwidth: 1, align: 'left' } ];
      }
      renderResponsivePlot('oos_wf_mc_hist', traces, layout);
      setupResize('oos_wf_mc_hist');
      makeTable('oos_wf_mc_metrics', data.metrics);
      makeTable('oos_wf_mc_params', data.params);
    }

    // -------- Responsive plot helpers --------
    function computePlotHeight(divId) {
      const el = document.getElementById(divId);
      const w = el ? el.clientWidth : 800;
      return Math.max(360, Math.min(600, Math.round(w * 0.50)));
    }
    function computePlotWidth(divId) {
      const el = document.getElementById(divId);
      return el ? el.clientWidth : 900;
    }
    function renderResponsivePlot(divId, traces, layout) {
      const h = computePlotHeight(divId);
      const w = computePlotWidth(divId);
      const ly = Object.assign({}, layout, { height: h, width: w, autosize: false });
      const el = document.getElementById(divId);
      if (el) el.style.width = '100%';
      Plotly.newPlot(divId, traces, ly, { responsive: true, displayModeBar: true });
    }
    function setupResize(divId) {
      if (!window._plotResizers) window._plotResizers = new Set();
      if (window._plotResizers.has(divId)) return;
      window._plotResizers.add(divId);
      window.addEventListener('resize', () => {
        const h = computePlotHeight(divId);
        const w = computePlotWidth(divId);
        Plotly.relayout(divId, { height: h, width: w });
        Plotly.Plots.resize(divId);
      });
    }

    async function loadAll() {
      const folder = document.getElementById('folderInput').value;
      try { window._currentFolder = folder; } catch (_) {}
      const [isData, isMC, oosWF, oosWFMC] = await Promise.all([
        safeFetch(`${folder}/is.json`),
        safeFetch(`${folder}/is_mc.json`),
        safeFetch(`${folder}/oos_wf.json`),
        safeFetch(`${folder}/oos_wf_mc.json`),
      ]);
      plotIS(isData);
      plotISMC(isMC);
      plotOOSWF(oosWF);
      plotOOSWFMC(oosWFMC);
    }

    loadAll();
  </script>
</body>
</html>

